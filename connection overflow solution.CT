//connection overflow exploit solution by Bowie 02/2020
[ENABLE]
alloc(newmem,128)
{changes the offset for the user count value from 4 bytes
to 2 bytes, so that the value isn't fucked up. it seemed
to compare properly anyway, but it shouldn't be 4 bytes.}
0044EC62:
add [eax],al

0044EC64:
push esp

0044EC65:
db 65 6F
{opcodes to be replaced by my code. the instruction that
adds esi+00000128 will be replaced by it's address value.}
00411AB1:
db 90 90 90 90 90 90
{this comparison code is the reason the exploit happened.}
00411AB7:
db 90 90 90 90 90 90
{this conditional jump has been added to the new opcodes.}
00411ABD:
nop
nop
{the original code compares idle game.exe connections to
the max user limit, and will disallow connections if the
connection count is not less than the max user value. at
this point, these users have not successfully logged in.
basically, someone could open the client as many time as
necessary, without logging in, and max out connections.}
newmem: //compares max user value to active user logins
mov ax,word ptr [00477CEC] //max user value
add ax,word ptr [00477CE8] //no clue why this returns 0
mov cx,word ptr [0044EC60] //user login count
cmp cx,ax //compare max users to active user logins
jnl 00411A82 //jump if not less to disconnect the client
jmp 00411ABF //exit the procedure to allow entry if less

00411AAB:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
00411AAB:
mov eax,[esi+0000012C]

00411AB1:
add eax,[esi+00000128]

00411AB7:
cmp [esi+00000138],eax

00411ABD:
jnl 00411A82

0044EC62:
call 6FAA406A
